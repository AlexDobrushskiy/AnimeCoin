import asyncio
import random
import logging

import zmq
import zmq.asyncio

from .settings import NetWorkSettings
from .chunk_manager import ChunkManager
from .masternode_communication import NodeManager
from .helpers import get_digest, get_hexdigest, hex_to_int, int_to_hex
from .animecoin_modules.animecoin_rpc import pack_and_sign, verify_and_unpack


class MasterNode:
    def __init__(self, name, nodeid, masternode_settings, masternode_list):
        self.__name = name
        self.__nodeid = hex_to_int(nodeid)
        self.__todolist = asyncio.Queue()

        # initialize logging
        self.__initlogging()

        # settings
        self.__masternode_settings = masternode_settings

        # masternode manager
        self.__mn_manager = NodeManager(masternode_list)

        # chunk manager
        self.__chunkmanager = ChunkManager(self.__logger, self.__nodeid,
                                           self.__masternode_settings.BASEDIR,
                                           self.__mn_manager, self.__todolist)

        # message queue
        mn = self.__mn_manager.get(self.__nodeid)

        # functions exposed from chunkmanager
        self.load_full_chunks = self.__chunkmanager.load_full_chunks
        self.load_chunks = self.__chunkmanager.load_chunks

        # our RPC socket
        self.__zmq = zmq.asyncio.Context().socket(zmq.ROUTER)
        self.__zmq.setsockopt(zmq.IDENTITY, bytes(str(self.__nodeid), "utf-8"))
        self.__zmq.bind("tcp://%s:%s" % (mn.ip, mn.port))

    def __initlogging(self):
        self.__logger = logging.getLogger(self.__name)
        self.__logger.setLevel(logging.DEBUG)

        formatter = logging.Formatter(' %(asctime)s - ' + self.__name + ' - %(levelname)s - %(message)s')
        consolehandler = logging.StreamHandler()
        consolehandler.setFormatter(formatter)
        self.__logger.addHandler(consolehandler)

    async def issue_random_tests_forever(self, waittime, number_of_chunks=1):
        while True:
            await asyncio.sleep(waittime)

            chunks = self.__chunkmanager.select_random_chunks(number_of_chunks)
            for chunkid in chunks:
                self.__logger.debug("Selected chunk %s for random check" % int_to_hex(chunkid))

                # get chunk
                data = self.__chunkmanager.get_chunk(chunkid, verify=True)

                # pick a random range
                assert len(data) > 1024
                start = random.randint(0, len(data)-1024)
                end = start + 1024

                # calculate digest
                digest = get_hexdigest(data[start:end])
                self.__logger.debug("Digest for range %s - %s is: %s" % (start, end, digest))

                # find owners for all the alt keys who are not us
                owners = self.__chunkmanager.find_owners_for_chunk(chunkid)
                if self.__nodeid in owners:
                    # we have already tested ourselves with verify()
                    owners.remove(self.__nodeid)

                # call RPC on all other MNs
                for owner in owners:
                    mn = self.__mn_manager.get(owner)

                    response_digest = await self.__send_rpc_spotcheck(mn, chunkid, start, end)

                    if response_digest != digest:
                        self.__logger.warning("SPOTCHECK FAILED for node %s (%s != %s)" % (owner, digest,
                                                                                           response_digest))
                    else:
                        self.__logger.debug("SPOTCHECK SUCCESS for node %s for chunk: %s" % (owner, digest))

                    # TODO: track successes/errors

    async def run_workers_forever(self):
        while True:
            self.__logger.debug("TODOLIST: queue size: %s" % self.__todolist.qsize())
            todoitem = await self.__todolist.get()

            itemtype, itemdata = todoitem
            if itemtype == "MISSING_CHUNK":
                chunkid = itemdata
                self.__logger.debug("Fetching chunk %s" % chunkid)

                # TODO: do we try all MNs?
                for owner in self.__chunkmanager.find_owners_for_chunk(chunkid):
                    if owner == self.__nodeid:
                        continue
                    mn = self.__mn_manager.get(owner)

                    chunk = await self.__send_rpc_fetchchunk(mn, chunkid)
                    self.__logger.debug("Fetched chunk %s" % len(chunk))
            else:
                raise ValueError("Invalid todo type: %s" % itemtype)
            self.__todolist.task_done()

    async def __zmq_process(self, ident, msg):
        sender_id, received_msg = verify_and_unpack(msg, self.__masternode_settings.PUBKEY)
        rpcname, data = received_msg

        if rpcname == "SPOTCHECK_REQ":
            reply_packet = self.__receive_rpc_spotcheck(sender_id, data)
        elif rpcname == "FETCHCHUNK_REQ":
            reply_packet = self.__receive_rpc_fetchchunk(sender_id, data)
        else:
            # TODO: signal error
            raise NotImplementedError("Invalid rpc name")

        await self.__zmq.send_multipart([ident, reply_packet])

    async def zmq_run_forever(self):
        while True:
            ident, msg = await self.__zmq.recv_multipart()  # waits for msg to be ready
            asyncio.ensure_future(self.__zmq_process(ident, msg))

    async def __send_rpc_spotcheck(self, mn, chunkid, start, end):
        self.__logger.debug("SPOTCHECK REQUEST to %s, chunkid: %s" % (int_to_hex(mn.nodeid), int_to_hex(chunkid)))

        # chunkid is bignum so we need to serialize it
        chunkid_str = int_to_hex(chunkid)
        request_msg = ["SPOTCHECK_REQ", {"chunkid": chunkid_str, "start": start, "end": end}]

        request_packet = pack_and_sign(self.__masternode_settings.PRIVKEY,
                                       self.__masternode_settings.PUBKEY,
                                       mn.pubkey, request_msg)

        response_packet = await mn.send_rpc_and_wait_for_response(request_packet)

        sender_id, response_msg = verify_and_unpack(response_packet, self.__masternode_settings.PUBKEY)

        rpcname, response_data = response_msg

        if rpcname != "SPOTCHECK_RESP":
            raise ValueError("Spotcheck response has rpc name: %s" % rpcname)

        if set(response_data.keys()) != {"digest"}:
            raise ValueError("RPC parameters are wrong for SPOTCHECK_RESP: %s" % response_data.keys())

        if type(response_data["digest"]) != str:
            raise TypeError("digest is not str: %s" % type(response_data["digest"]))

        response_digest = response_data["digest"]

        self.__logger.debug("SPOTCHECK RESPONSE from %s, msg: %s" % (int_to_hex(mn.nodeid), response_digest))

        return response_digest

    def __receive_rpc_spotcheck(self, sender_id, data):
        # NOTE: data is untrusted!
        if not isinstance(data, dict):
            raise TypeError("Data must be a dict!")

        if set(data.keys()) != {"chunkid", "start", "end"}:
            raise ValueError("Invalid arguments for spotcheck: %s" % (data.keys()))

        for k, v in data.items():
            if k in ["start", "end"]:
                if not isinstance(v, int):
                    raise TypeError("Invalid type for key %s in spotcheck" % k)
            else:
                if not isinstance(v, str):
                    raise TypeError("Invalid type for key %s in spotcheck" % k)

        chunkid = hex_to_int(data["chunkid"])
        start = data["start"]
        end = data["end"]

        # check if start and end are within parameters
        if start < 0:
            raise ValueError("start is < 0")
        if start >= end:
            raise ValueError("start >= end")
        if start > NetWorkSettings.CHUNKSIZE or end > NetWorkSettings.CHUNKSIZE:
            raise ValueError("start > CHUNKSIZE or end > CHUNKSIZE")

        # we don't actually need the full chunk here, but we get it anyway as we are running verify() on it
        chunk = self.__chunkmanager.return_chunk_data_if_valid_and_owned_and_we_have_it(chunkid)

        # generate digest
        data = chunk[start:end]
        digest = get_hexdigest(data)

        # generate response
        request_msg = ["SPOTCHECK_RESP", {"digest": digest}]

        response_packet = pack_and_sign(self.__masternode_settings.PRIVKEY,
                                        self.__masternode_settings.PUBKEY,
                                        sender_id, request_msg)

        return response_packet

    async def __send_rpc_fetchchunk(self, mn, chunkid):
        self.__logger.debug("FETCHCHUNK REQUEST to %s, chunkid: %s" % (int_to_hex(mn.nodeid), int_to_hex(chunkid)))

        # chunkid is bignum so we need to serialize it
        chunkid_str = int_to_hex(chunkid)
        request_msg = ["FETCHCHUNK_REQ", {"chunkid": chunkid_str}]

        request_packet = pack_and_sign(self.__masternode_settings.PRIVKEY,
                                       self.__masternode_settings.PUBKEY,
                                       mn.pubkey, request_msg)

        response_packet = await mn.send_rpc_and_wait_for_response(request_packet)

        sender_id, response_msg = verify_and_unpack(response_packet, self.__masternode_settings.PUBKEY)

        rpcname, response_data = response_msg

        if rpcname != "FETCHCHUNK_RESP":
            raise ValueError("FETCHCHUNK response has rpc name: %s" % rpcname)

        if set(response_data.keys()) != {"chunk"}:
            raise ValueError("RPC parameters are wrong for SPOTCHECK_RESP: %s" % response_data.keys())

        if type(response_data["chunk"]) != bytes:
            raise TypeError("chunk is not bytes: %s" % type(response_data["chunk"]))

        chunk = response_data["chunk"]

        # validate chunk
        digest = get_hexdigest(chunk)
        if digest != chunkid_str:
            raise ValueError("Got chunk data that does not match the digest!")

        return chunk

    def __receive_rpc_fetchchunk(self, sender_id, data):
        # NOTE: data is untrusted!
        if not isinstance(data, dict):
            raise TypeError("Data must be a dict!")

        if set(data.keys()) != {"chunkid"}:
            raise ValueError("Invalid arguments for spotcheck: %s" % (data.keys()))

        if not isinstance(data["chunkid"], str):
            raise TypeError("Invalid type for key chunkid in spotcheck")

        chunkid = hex_to_int(data["chunkid"])

        # TODO: error handling
        chunk = self.__chunkmanager.return_chunk_data_if_valid_and_owned_and_we_have_it(chunkid)

        # generate response
        request_msg = ["FETCHCHUNK_RESP", {"chunk": chunk}]

        response_packet = pack_and_sign(self.__masternode_settings.PRIVKEY,
                                        self.__masternode_settings.PUBKEY,
                                        sender_id, request_msg)

        return response_packet
