import asyncio
import random
import logging

from .chunk_manager import ChunkManager
from .zmq_rpc import RPCFailed, RPCServer
from .masternode_communication import NodeManager
from .helpers import get_hexdigest, hex_to_int, int_to_hex


class MasterNodeLogic:
    def __init__(self, name, nodeid, basedir, privkey, pubkey, ip, port, chunks):
        self.__name = name
        self.__nodeid = hex_to_int(nodeid)
        self.__basedir = basedir
        self.__privkey = privkey
        self.__pubkey = pubkey
        self.__ip = ip
        self.__port = port

        self.__todolist = asyncio.Queue()

        # initialize logging
        self.__initlogging()

        # masternode manager
        self.__mn_manager = NodeManager(self.__logger, self.__privkey, self.__pubkey)
        self.add_masternode(self.__nodeid, self.__ip, self.__port, self.__pubkey)

        # chunk manager
        self.__chunkmanager = ChunkManager(self.__logger, self.__nodeid,
                                           basedir,
                                           chunks,
                                           self.__mn_manager, self.__todolist)

        # functions exposed from chunkmanager
        self.load_full_chunks = self.__chunkmanager.load_full_chunks

        # start rpc server
        self.__rpcserver = RPCServer(self.__logger, self.__nodeid, self.__ip, self.__port,
                                     self.__privkey, self.__pubkey, self.__chunkmanager)

    def __initlogging(self):
        self.__logger = logging.getLogger(self.__name)
        self.__logger.setLevel(logging.DEBUG)

        formatter = logging.Formatter(' %(asctime)s - ' + self.__name + ' - %(levelname)s - %(message)s')
        consolehandler = logging.StreamHandler()
        consolehandler.setFormatter(formatter)
        self.__logger.addHandler(consolehandler)

    def add_masternode(self, nodeid, ip, port, pubkey):
        self.__mn_manager.add_masternode(nodeid, ip, port, pubkey)

    async def issue_random_tests_forever(self, waittime, number_of_chunks=1):
        while True:
            await asyncio.sleep(waittime)

            chunks = self.__chunkmanager.select_random_chunks_we_have(number_of_chunks)
            for chunkid in chunks:
                self.__logger.debug("Selected chunk %s for random check" % int_to_hex(chunkid))

                # get chunk
                data = self.__chunkmanager.get_chunk(chunkid, verify=True)

                # pick a random range
                assert len(data) > 1024
                start = random.randint(0, len(data)-1024)
                end = start + 1024

                # calculate digest
                digest = get_hexdigest(data[start:end])
                self.__logger.debug("Digest for range %s - %s is: %s" % (start, end, digest))

                # find owners for all the alt keys who are not us
                owners = self.__chunkmanager.find_owners_for_chunk(chunkid)
                if self.__nodeid in owners:
                    # we have already tested ourselves with verify()
                    owners.remove(self.__nodeid)

                # call RPC on all other MNs
                for owner in owners:
                    mn = self.__mn_manager.get(owner)

                    try:
                        response_digest = await mn.send_rpc_spotcheck(chunkid, start, end)
                    except RPCFailed as exc:
                        self.__logger.info("SPOTCHECK RPC FAILED for node %s with exception %s" % (owner, exc))
                    else:
                        if response_digest != digest:
                            self.__logger.warning("SPOTCHECK FAILED for node %s (%s != %s)" % (owner, digest,
                                                                                               response_digest))
                        else:
                            self.__logger.debug("SPOTCHECK SUCCESS for node %s for chunk: %s" % (owner, digest))

                    # TODO: track successes/errors

    async def run_heartbeat_forever(self):
        while True:
            await asyncio.sleep(1)

            mn = self.__mn_manager.get_random()
            if mn is None:
                continue

            data = b'PING'

            try:
                response_data = await mn.send_rpc_ping(data)
            except RPCFailed as exc:
                self.__logger.info("PING RPC FAILED for node %s with exception %s" % (mn, exc))
            else:
                if response_data != data:
                    self.__logger.warning("PING FAILED for node %s (%s != %s)" % (mn, data, response_data))
                else:
                    self.__logger.debug("PING SUCCESS for node %s for chunk: %s" % (mn, data))

                # TODO: track successes/errors

    async def run_workers_forever(self):
        # TODO: speed this up (multiple coroutines perhaps?)
        while True:
            self.__logger.debug("TODOLIST: queue size: %s" % self.__todolist.qsize())
            todoitem = await self.__todolist.get()

            itemtype, itemdata = todoitem
            if itemtype == "MISSING_CHUNK":
                chunkid = itemdata
                self.__logger.debug("Fetching chunk %s" % chunkid)

                found = False
                for owner in self.__chunkmanager.find_owners_for_chunk(chunkid):
                    if owner == self.__nodeid:
                        continue
                    mn = self.__mn_manager.get(owner)

                    try:
                        chunk = await mn.send_rpc_fetchchunk(chunkid)
                    except RPCFailed as exc:
                        self.__logger.info("FETCHCHUNK RPC FAILED for node %s with exception %s" % (owner, exc))
                        continue
                    else:
                        found = True
                        self.__logger.debug("Fetched chunk %s" % len(chunk))
                        break

                # nobody has this chunk
                if not found:
                    # TODO: fall back to reconstruct it from luby blocks
                    raise RuntimeError("Unable to fetch chunk %s!" % chunkid)

                # we have the chunk, store it!
                self.__chunkmanager.store_chunk(chunkid, chunk)

                # mark entry as done
                self.__todolist.task_done()
            else:
                raise ValueError("Invalid todo type: %s" % itemtype)

    async def zmq_run_forever(self):
        await self.__rpcserver.zmq_run_forever()
