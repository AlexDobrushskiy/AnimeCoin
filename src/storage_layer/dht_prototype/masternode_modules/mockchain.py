import random


class BlockChainTicket:
    def __init__(self, tickettype, data):
        self.tickettype = tickettype
        self.data = data


class BlockChain:
    def __init__(self):
        self.__chain = []
        self.__utxo_index = {}

    def search_chain(self):
        for txid, ticket in self.__chain:
            yield txid, ticket

    def __add_to_chain(self, ticket):
        txid = len(self.__chain).to_bytes(32, byteorder='big')
        self.__utxo_index[txid] = len(self.__chain)
        self.__chain.append((txid, ticket))
        return txid

    def store_data_in_utxo(self, tickettype, data):
        ticket = BlockChainTicket(tickettype=tickettype, data=data)
        return self.__add_to_chain(ticket)

    def retrieve_data_from_utxo(self, txid):
        idx = self.__utxo_index[txid]
        return self.__chain[idx][1].data

    def get_block_distance(self, atxid, btxid):
        aidx = self.__utxo_index[atxid]
        bidx = self.__utxo_index[btxid]
        return abs(aidx-bidx)

    def get_last_block_hash(self):
        return self.__chain[-1][0]


class ChainWrapper:
    def __init__(self, blockchain):
        self.__blockchain = blockchain

    def get_all_fingerprints(self):
        # TODO: check mempool as well!
        for txid, ticket in self.__blockchain.search_chain():
            # TODO figure out ticket types and parse them
            pass

    def get_block_distance(self, atxid, btxid):
        return self.__blockchain.get_block_distance(atxid, btxid)

    def get_last_block_hash(self):
        return self.__blockchain.get_last_block_hash()

    def store_ticket(self, tickettype, data):
        return self.__blockchain.store_data_in_utxo(tickettype=tickettype, data=data)

    def retrieve_ticket(self, txid):
        return self.__blockchain.retrieve_data_from_utxo(txid)

    def all_ticket_iterator(self):
        for txid, ticket in self.__blockchain.search_chain():
            yield ticket

    def __get_masternodes_from_blockchain(self, target_txid=None):
        for txid, ticket in self.__blockchain.search_chain():
            if ticket.tickettype == "masternode":
                pubkey, mn = ticket.data[0], ticket.data[1]
                yield pubkey, mn
            if target_txid is not None and txid == target_txid:
                break

    def get_masternode_order(self, target_txid):
        # get MNs that were active at target_txid time
        masternodes = [pubkey for pubkey, mn in self.__get_masternodes_from_blockchain(target_txid)]

        # generate a reproducible sample of the MN population, then reset the random seed
        random.seed(target_txid)
        random_sample = random.sample(masternodes, 3)
        random.seed()
        # end

        random_sample.sort()
        return random_sample

    # MASTERNODE STUFF WE HAVE TO ACCESS GLOBALLY
    def register_masternode(self, pubkey, mn):
        self.__blockchain.store_data_in_utxo(tickettype="masternode", data=(pubkey, mn))

    def get_masternode(self, key):
        for pubkey, mn in self.__get_masternodes_from_blockchain():
            if pubkey == key:
                return mn
        raise KeyError("Masternode for key %s does not exist!" % key)
    # END
