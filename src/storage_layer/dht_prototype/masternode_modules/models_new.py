import msgpack

from .animecoin_modules.helpers import get_sha3_512_func_bytes
from .model_validators import PubKeyField, StringField, IntegerField, ListField, SHA3512Field, LubyChunkHashField,\
    BytesField, LubyChunkField, ImageField, ThumbnailField, TXIDField


def serialize(data):
    return msgpack.packb(data, use_bin_type=True)


def unserialize(packed):
    return msgpack.unpackb(packed, raw=False)


# ===== VALIDATORS ===== #
class NotImplementedValidator:
    msg = "You forgot to set \"validators\" while inheriting from ModelBase!"

    def __index__(self):
        raise NotImplementedError(self.msg)

    def __getattr__(self, item):
        raise NotImplementedError(self.msg)


class NotImplementedMethods:
    msg = "Your forgot to set \"methods\" while inheriting from ContainerModelBase!"

    def keys(self):
        raise NotImplementedError(self.msg)

    def items(self, item):
        raise NotImplementedError(self.msg)


class ModelBase:
    validators = NotImplementedValidator()

    def __init__(self, data):
        # validate data
        if type(data) != dict:
            raise TypeError("data should be a dict!")

        # validate all keys in data
        a, b = set(data.keys()), set(self.validators.keys())
        if len(a - b) + len(b - a) > 0:
            raise KeyError("Keys don't match %s != %s" % (a, b))

        # validate values one by one
        for k, v in data.items():
            setattr(self, k, v)

    def __setattr__(self, key, value):
        validator = self.validators[key]
        validator.validate(value)
        self.__dict__[key] = value

    def __eq__(self, other):
        return self.__dict__ == other

    def serialize(self):
        serialized = serialize(self.__dict__)
        return serialized

    def to_dict(self):
        ret = {}
        keys = sorted(self.__dict__.keys())
        for k in keys:
            v = self.__dict__[k]
            # ret[k] = v.serialize()
            ret[k] = v
        return ret


class ContainerModelBase:
    methods = NotImplementedMethods()
    """
        This class supports two constructors:
          o dictonary if you want to pass in the dictionary for the models directly, or
          o serialized if you want to pass in msgpack()ed data from the wire
        """

    def __init__(self, dictionary=None, serialized=None):
        if dictionary is None and serialized is None:
            raise ValueError("You have to set at least dictionary or serialized")

        if serialized is not None:
            unserialized = self.unserialize(serialized)
            dictionary = self.from_dict(unserialized)

        # validate dictionary
        if type(dictionary) != dict:
            raise TypeError("data should be a dict!")

        # validate all keys in data
        a, b = set(dictionary.keys()), set(self.methods.keys())
        if len(a - b) + len(b - a) > 0:
            raise KeyError("Keys don't match %s != %s" % (a, b))

        for name, validator in self.methods.items():
            validated = validator(dictionary[name])
            setattr(self, name, validated)

    def __eq__(self, other):
        return self.__dict__ == other

    def to_dict(self):
        ret = {}
        keys = sorted(self.__dict__.keys())
        for k in keys:
            v = self.__dict__[k]
            # ret[k] = v.serialize()
            ret[k] = v.to_dict()
        return ret

    def serialize(self):
        return serialize(self.to_dict())

    def from_dict(self, dictionary):
        return dictionary

    def unserialize(self, packed):
        return unserialize(packed)

    def get_hash(self):
        return get_sha3_512_func_bytes(self.serialize())

    def validate(self):
        raise NotImplementedError()
# ===== END ===== #


# ===== START NEW STYLE TICKETS ===== #
class ArtistInfoModel(ModelBase):
    validators = {
        "ARTIST_USERID": TXIDField(),
        "ARTIST_NAME": StringField(minsize=0, maxsize=120),
        "ARTIST_WEBSITE": StringField(minsize=0, maxsize=120),
        "ARTIST_WRITTEN_STATEMENT": StringField(minsize=0, maxsize=120),
    }


class ArtInfoModel(ModelBase):
    validators = {
        "ARTWORK_TITLE": StringField(minsize=0, maxsize=120),
        "ARTWORK_SERIES_NAME": StringField(minsize=0, maxsize=120),
        "ARTWORK_CREATION_VIDEO_YOUTUBE_URL": StringField(minsize=0, maxsize=120),
        "ARTWORK_KEYWORD_SET": StringField(minsize=0, maxsize=120),
        "TOTAL_COPIES": IntegerField(minsize=0, maxsize=120),
    }


class FingerPrintsModel(ModelBase):
    validators = {
        "FINGERPRINTS": ListField(minsize=8064, maxsize=8064, innertype=float),
    }


class LubyHashesModel(ModelBase):
    validators = {
        "LUBY_CHUNK_HASHES": LubyChunkHashField(),
    }


class SHA3512Model(ModelBase):
    validators = {
        "HASH": SHA3512Field(),
    }


class LubyChunksModel(ModelBase):
    validators = {
        "CHUNKS": LubyChunkField(),
    }

    def get_hashes(self):
        hashes = []
        for chunk in self.CHUNKS:
            hashes.append(get_sha3_512_func_bytes(chunk))
        return hashes


class ThumbnailModel(ModelBase):
    validators = {
        "THUMBNAIL": ThumbnailField(),
    }

    def get_hash(self):
        return get_sha3_512_func_bytes(self.THUMBNAIL)


class ArtworkModel(ModelBase):
    validators = {
        "ARTWORK": ImageField(),
    }


class TXID(ModelBase):
    validators = {
        "TXID": TXIDField(),
    }
# ===== END ===== #


# ===== START NEW STYLE MODELS ===== #
class ImageData(ContainerModelBase):
    methods = {
        "image": ArtworkModel,
        "lubychunks": LubyChunksModel,
        "thumbnail": ThumbnailModel,
    }

    def get_artwork_hash(self):
        return get_sha3_512_func_bytes(self.image.ARTWORK)

    # TODO: these staticmethods can go somewhere else
    @staticmethod
    def generate_fingerprints(imagedata):
        # TODO: do this properly
        print("MOCKING __generate_fingerprints!")
        prints = [float(x) for x in range(0, 8064)]
        return prints

    @staticmethod
    def generate_luby_chunks(imagedata):
        # TODO: do this properly
        print("MOCKING __generate_luby_chunks!")
        chunks = []
        processed = 0
        while processed < len(imagedata):
            chunks.append(imagedata[processed:processed + 1024 * 1024])
            processed += 1024 * 1024
        return {"CHUNKS": chunks}

    @staticmethod
    def generate_thumbnail(imagedata):
        # TODO: do this properly
        print("MOCKING __generate_thumbnail!")
        return {"THUMBNAIL": b"\x89PNGTESTTESTTEST"}

    def validate(self):
        # validate that luby chunks are good
        # TODO: we should rather do this by:
        #   o assembling the original image and making sure it matches
        #   o checking if chunks are actually generated well
        new_luby_chunks = self.generate_luby_chunks(self.image.ARTWORK)
        assert(self.lubychunks == new_luby_chunks)

        # validate that thumbnail is the same image
        # TODO: we should not regenerate the thumbnail, just look for similarities
        new_thumbnail = self.generate_thumbnail(self.image.ARTWORK)
        assert (self.thumbnail == new_thumbnail)


class MetaData(ContainerModelBase):
    methods = {
        "artistinfo": ArtistInfoModel,
        "artinfo": ArtInfoModel,
        "fingerprints": FingerPrintsModel,
        "lubyhashes": LubyHashesModel,
        "thumbnailhash": SHA3512Model,
    }

    def validate(self):
        # TODO: figure out if this has any point, metadata can't really be validated without
        # having access to the original image or an ImageData
        # TODO: maybe this should be a ModelBase and not a ContainerModelBase?

        # TODO:
        #  o validate:
        #    o fingerprints
        #    o lubyhashes
        #    o thumbnailhash
        raise NotImplementedError()


class RegistrationTicket(ContainerModelBase):
    methods = {
        "imagedata_hash": SHA3512Model,
        "metadata_hash": SHA3512Model,
    }

    def validate(self, metadata, blockchain):
        # TODO:
        # o validate that metadata hash matches
        # o validate that art hash doesn't exist:
        #   o check all active art on chain
        #   o check in progress registration
        # o validate that fingerprints are not dupes
        #   o check all active art on chain
        #   o check all started registration (so we avoid races)
        #
        # after these checks are done we know that
        # o fingerprints are not dupes and there is no race
        # o all metadata fields look valid syntactically (have the right types and sizes etc...)
        #   o but this is NOT verified in context such as with the blockchain or other tickets
        raise NotImplementedError()


class ActivationTicket(ContainerModelBase):
    methods = {
        "registration_ticket_txid": TXID,
        "metadata_hash": SHA3512Model,
    }

    def validate(self, imagedata, metadata, blockchain):
        # TODO:
        # o validate that this ticket references a valid regticket
        #   o regticket is on chain
        #   o regticket is not yet activated
        #   o regticket signatures are valid
        # o validate that metadata hash matches
        # o validate metadata:
        #   o fingerprints matches image
        #   o lubyhashes matches image
        #   o thumbnailhash matches image
        # o validate image
        #   o image actually hashes to imagedata_hash in the regticket
        #   o image is sfw - TODO: can we do this in the prev step using some fingerprint?
        #   o luby chunks generate the image

        raise NotImplementedError()


class SignedTicket(ContainerModelBase):
    # TODO: convert init to containermodelbase
    def __init__(self, ticket, signatures):
        self.activation_ticket = ticket
        self.signatures = signatures

    def validate(self):
        raise NotImplementedError()


class MasterTicket:
    # TODO: convert init to containermodelbase
    def __init__(self):
        self.imagedata = ImageData()
        self.metadata = MetaData()
        self.signed_regticket = SignedTicket()
        self.signed_activationticket = SignedTicket()

    def validate(self):
        # TODO:
        # validate EVERYTHING!
        # validate signatures
        raise NotImplementedError()
# ===== END ===== #
