import msgpack

from .animecoin_modules.helpers import get_sha3_512_func_bytes
from dht_prototype.masternode_modules.animecoin_modules.animecoin_signatures import\
    animecoin_id_write_signature_on_data_func, animecoin_id_verify_signature_with_public_key_func
from .model_validators import StringField, IntegerField, ListField, SHA3512Field, LubyChunkHashField,\
    LubyChunkField, ImageField, ThumbnailField, TXIDField, SignatureField, TicketField, PubkeyField


# ===== SERIALIZERS ===== #
def serialize(data):
    return msgpack.packb(data, use_bin_type=True)


def unserialize(packed):
    return msgpack.unpackb(packed, raw=False)
# ===== END ===== #


# ===== VALIDATORS ===== #
class NotImplementedValidator:
    msg = "You forgot to set \"validators\" while inheriting from ModelBase!"

    def __index__(self):
        raise NotImplementedError(self.msg)

    def __getattr__(self, item):
        raise NotImplementedError(self.msg)

    def __call__(self, *args, **kwargs):
        raise NotImplementedError(self.msg)


class NotImplementedMethods:
    msg = "Your forgot to set \"methods\" while inheriting from ContainerModelBase!"

    def keys(self):
        raise NotImplementedError(self.msg)

    def items(self, item):
        raise NotImplementedError(self.msg)


class TicketModelBase:
    methods = NotImplementedMethods()
    """
        This class supports two constructors:
          o dictonary if you want to pass in the dictionary for the models directly, or
          o serialized if you want to pass in msgpack()ed data from the wire
        """

    def __init__(self, dictionary=None, serialized=None):
        # internal data structures
        # TODO: using __dict__ like this is not very elegant
        self.__dict__["__locked"] = False
        self.__data = {}
        # end

        if dictionary is None and serialized is None:
            raise ValueError("You have to set at least dictionary or serialized")

        if serialized is not None:
            unserialized = self.unserialize(serialized)
            dictionary = unserialized

        # validate dictionary
        if type(dictionary) != dict:
            raise TypeError("data should be a dict!")

        # validate all keys in data
        a, b = set(dictionary.keys()), set(self.methods.keys())
        if len(a - b) + len(b - a) > 0:
            raise KeyError("Keys don't match %s != %s" % (a, b))

        for name, validator in self.methods.items():
            value = dictionary[name]
            setattr(self, name, value)

        # lock setattr
        self.__dict__["__locked"] = True

    def __getattr__(self, key):
        # TODO: refactor getattr and setattr and use self.__class__.methods for
        # validation and not the lock. We don't really need the class to be immutable,
        # we are just trying to prevent the mistake of setting a data member accidentally and
        # thus circumventing validation.
        locked = self.__dict__["__locked"]
        if locked:
            return self.__data[key]
        else:
            return self.__dict__[key]

    def __setattr__(self, key, value):
        locked = self.__dict__["__locked"]
        if locked:
            raise NameError("Tried to set key %s, which is forbidden (use constructor)!" % key)

        if key.startswith("_"):
            self.__dict__[key] = value
        else:
            validator = self.__class__.methods[key]
            try:
                validated = validator.validate(value)
            except Exception as exc:
                print("EXCEPTION %s in validator k: %s, v: %s" % (exc, validator, key))
                raise
            self.__data[key] = validated

    def __eq__(self, other):
        return self.__data == other

    def to_dict(self):
        ret = {}
        keys = sorted(self.__data.keys())
        for k in keys:
            v = self.__data[k]
            ret[k] = v
        return ret

    def serialize(self):
        return serialize(self.to_dict())

    def unserialize(self, packed):
        return unserialize(packed)

    def get_hash(self):
        return get_sha3_512_func_bytes(self.serialize())

    def validate(self, *args, **kwargs):
        raise NotImplementedError()
# ===== END ===== #


# ===== START NEW STYLE MODELS ===== #
class ImageData(TicketModelBase):
    methods = {
        "image": ImageField(),
        "lubychunks": LubyChunkField(),
        "thumbnail": ThumbnailField(),
    }

    def get_artwork_hash(self):
        return get_sha3_512_func_bytes(self.image)

    # TODO: these staticmethods can go somewhere else
    @staticmethod
    def generate_fingerprints(imagedata):
        # TODO: do this properly
        print("MOCKING __generate_fingerprints!")
        prints = [float(x) for x in range(0, 8064)]
        return prints

    @staticmethod
    def generate_luby_chunks(imagedata):
        # TODO: do this properly
        print("MOCKING __generate_luby_chunks!")
        chunks = []
        processed = 0
        while processed < len(imagedata):
            chunks.append(imagedata[processed:processed + 1024 * 1024])
            processed += 1024 * 1024
        return chunks

    @staticmethod
    def generate_thumbnail(imagedata):
        # TODO: do this properly
        print("MOCKING __generate_thumbnail!")
        return b"\x89PNGTESTTESTTEST"

    def get_luby_hashes(self):
        hashes = []
        for chunk in self.lubychunks:
            hashes.append(get_sha3_512_func_bytes(chunk))
        return hashes

    def get_thumbnail_hash(self):
        return get_sha3_512_func_bytes(self.thumbnail)

    def validate(self):
        # validate that luby chunks are good
        # TODO: we should rather do this by:
        #   o assembling the original image and making sure it matches
        #   o checking if chunks are actually generated well
        new_luby_chunks = self.generate_luby_chunks(self.image)
        assert(self.lubychunks == new_luby_chunks)

        # validate that thumbnail is the same image
        # TODO: we should not regenerate the thumbnail, just look for similarities
        new_thumbnail = self.generate_thumbnail(self.image)
        assert (self.thumbnail == new_thumbnail)


class MetaData(TicketModelBase):
    methods = {
        "artist_userid": TXIDField(),
        "artist_name": StringField(minsize=0, maxsize=120),
        "artist_website": StringField(minsize=0, maxsize=120),
        "artist_written_statement": StringField(minsize=0, maxsize=120),
        "artwork_title": StringField(minsize=0, maxsize=120),
        "artwork_series_name": StringField(minsize=0, maxsize=120),
        "artwork_creation_video_youtube_url": StringField(minsize=0, maxsize=120),
        "artwork_keyword_set": StringField(minsize=0, maxsize=120),
        "total_copies": IntegerField(minsize=0, maxsize=120),

        "fingerprints": ListField(minsize=8064, maxsize=8064, innertype=float),
        "lubyhashes": LubyChunkHashField(),
        "thumbnailhash": SHA3512Field(),
    }

    def validate(self, image):
        # validate that fingerprints, lubyhashes and thumbnailhash indeed belong to the image
        assert(self.fingerprints == image.generate_fingerprints(image))
        assert(self.lubyhashes == image.get_luby_hashes())
        assert(self.thumbnailhash == image.get_thumbnail_hash())


class RegistrationTicket(TicketModelBase):
    methods = {
        "author": PubkeyField(),
        "imagedata_hash": SHA3512Field(),
        "metadata_hash": SHA3512Field(),
    }

    def validate(self, metadata, blockchain):
        # we have no way to check these but will do so on activation:
        #  o lubyhashes
        #  o thumbnailhash
        #
        # after these checks are done we know that fingerprints are not dupes and there is no race

        # 1 validate that metadata hash matches
        assert(metadata.get_hash() == self.metadata_hash)

        # 2 validate that art hash doesn't exist:
        if blockchain.get_artwork(self.imagedata_hash) is not None:
            raise ValueError("Artwork already exists on chain: %s" % self.imagedata_hash)

        # 3 validate that fingerprints are not dupes
        all_fingerprints = blockchain.get_all_fingerprints()
        # TODO: check for fingerprint dupes


class ActivationTicket(TicketModelBase):
    methods = {
        "registration_ticket_txid": TXIDField(),
        "metadata_hash": SHA3512Field(),
    }

    def validate(self, imagedata, metadata, blockchain):
        # TODO:
        # o validate that this ticket references a valid regticket
        #   o regticket is on chain
        #   o regticket is not yet activated
        #   o regticket signatures are valid
        # o validate that metadata hash matches
        # o validate metadata:
        #   o fingerprints matches image
        #   o lubyhashes matches image
        #   o thumbnailhash matches image
        # o validate image
        #   o image actually hashes to imagedata_hash in the regticket
        #   o image is sfw - TODO: can we do this in the prev step using some fingerprint?
        #   o luby chunks generate the image

        raise NotImplementedError()


class Signature(TicketModelBase):
    methods = {
        "signature": SignatureField(),
        "pubkey": PubkeyField(),
    }

    def validate(self, data):
        if not animecoin_id_verify_signature_with_public_key_func(data, self.signature, self.pubkey):
            raise ValueError("Invalid signature")


class FinalRegistrationTicket(TicketModelBase):
    methods = {
        "metadata": TicketField(),
        "registration_ticket": TicketField(),
        "signature_author": TicketField(),
        "signature_1": TicketField(),
        "signature_2": TicketField(),
        "signature_3": TicketField(),
    }

    def validate(self, masternode_ordering, blockchain):
        # TODO: get masternode_list properly from blockchain

        # parse the data
        metadata = MetaData(serialized=self.metadata)
        regticket = RegistrationTicket(serialized=self.registration_ticket)
        sig_author = Signature(serialized=self.signature_author)
        sig_mn_1 = Signature(serialized=self.signature_1)
        sig_mn_2 = Signature(serialized=self.signature_2)
        sig_mn_3 = Signature(serialized=self.signature_3)

        # validate that the author is correct
        if sig_author.pubkey != regticket.author:
            raise ValueError("Signature pubkey does not match regticket.author!")

        # validate that pubkeys belong to the correct people
        if (sig_mn_1.pubkey != masternode_ordering[0] or
            sig_mn_2.pubkey != masternode_ordering[1] or
            sig_mn_3.pubkey != masternode_ordering[2]):
            raise ValueError("Invalid pubkey for masternode ordering")

        # validate signatures
        sig_author.validate(self.registration_ticket)
        sig_mn_1.validate(self.registration_ticket)
        sig_mn_2.validate(self.registration_ticket)
        sig_mn_3.validate(self.registration_ticket)

        # validate registration ticket
        regticket.validate(metadata, blockchain)


class MasterTicket:
    # TODO: convert init to containermodelbase
    def __init__(self):
        self.imagedata = ImageData()
        self.metadata = MetaData()
        self.signed_regticket = Signature()
        self.signed_activationticket = Signature()

    def validate(self):
        # TODO:
        # validate EVERYTHING!
        # validate signatures
        raise NotImplementedError()
# ===== END ===== #
