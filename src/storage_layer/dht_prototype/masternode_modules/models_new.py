import msgpack

from .animecoin_modules.helpers import get_sha3_512_func_bytes
from dht_prototype.masternode_modules.animecoin_modules.animecoin_signatures import\
    animecoin_id_write_signature_on_data_func, animecoin_id_verify_signature_with_public_key_func
from .model_validators import FieldValidator, StringField, IntegerField, ListField, SHA3512Field, LubyChunkHashField,\
    LubyChunkField, ImageField, ThumbnailField, TXIDField, SignatureField, PubkeyField


# ===== SERIALIZERS ===== #
def serialize(data):
    return msgpack.packb(data, use_bin_type=True)


def unserialize(packed):
    return msgpack.unpackb(packed, raw=False)
# ===== END ===== #


# ===== VALIDATORS ===== #
class NotImplementedValidator:
    msg = "You forgot to set \"validators\" while inheriting from ModelBase!"

    def __index__(self):
        raise NotImplementedError(self.msg)

    def __getattr__(self, item):
        raise NotImplementedError(self.msg)

    def __call__(self, *args, **kwargs):
        raise NotImplementedError(self.msg)


class NotImplementedMethods:
    msg = "Your forgot to set \"methods\" while inheriting from ContainerModelBase!"

    def keys(self):
        raise NotImplementedError(self.msg)

    def items(self, item):
        raise NotImplementedError(self.msg)


class TicketModelBase:
    methods = NotImplementedMethods()
    """
        This class supports two constructors:
          o dictonary if you want to pass in the dictionary for the models directly, or
          o serialized if you want to pass in msgpack()ed data from the wire
        """

    def __init__(self, dictionary=None, serialized=None):
        # internal data structures
        # TODO: using __dict__ like this is not very elegant
        self.__dict__["__locked"] = False
        self.__data = {}
        # end

        if dictionary is None and serialized is None:
            raise ValueError("You have to set at least dictionary or serialized")

        if serialized is not None:
            unserialized = self.unserialize(serialized)
            dictionary = unserialized

        # validate dictionary
        if type(dictionary) != dict:
            raise TypeError("data should be a dict!")

        # validate all keys in data
        a, b = set(dictionary.keys()), set(self.methods.keys())
        if len(a - b) + len(b - a) > 0:
            raise KeyError("Keys don't match %s != %s" % (a, b))

        for name, validator in self.methods.items():
            value = dictionary[name]
            setattr(self, name, value)

        # lock setattr
        self.__dict__["__locked"] = True

    def __is_field_validator(self, validator):
        validator_type = type(validator)
        if issubclass(validator_type, FieldValidator):
            return True
        elif validator_type == type and issubclass(validator, TicketModelBase):
            return False
        else:
            raise TypeError("Invalid validator! type: %s, validator: %s" % (validator_type, validator))

    def __getattr__(self, key):
        # TODO: refactor getattr and setattr and use self.__class__.methods for
        # validation and not the lock. We don't really need the class to be immutable,
        # we are just trying to prevent the mistake of setting a data member accidentally and
        # thus circumventing validation.
        locked = self.__dict__["__locked"]
        if locked:
            return self.__data[key]
        else:
            return self.__dict__[key]

    def __setattr__(self, key, value):
        locked = self.__dict__["__locked"]
        if locked:
            raise NameError("Tried to set key %s, which is forbidden (use constructor)!" % key)

        if key.startswith("_"):
            self.__dict__[key] = value
        else:
            validator = self.__class__.methods[key]
            if self.__is_field_validator(validator):
                validated = validator.validate(value)
            else:
                validated = validator(dictionary=value)

            self.__data[key] = validated

    def __eq__(self, other):
        return self.__data == other

    def to_dict(self):
        ret = {}
        keys = sorted(self.__data.keys())
        for k in keys:
            v = self.__data[k]

            validator = self.__class__.methods[k]
            if self.__is_field_validator(validator):
                ret[k] = v
            else:
                ret[k] = v.to_dict()
        return ret

    def serialize(self):
        return serialize(self.to_dict())

    def unserialize(self, packed):
        return unserialize(packed)

    def get_hash(self):
        return get_sha3_512_func_bytes(self.serialize())

    def validate(self, *args, **kwargs):
        raise NotImplementedError()
# ===== END ===== #


# ===== START NEW STYLE MODELS ===== #
class ImageData(TicketModelBase):
    methods = {
        "image": ImageField(),
        "lubychunks": LubyChunkField(),
        "thumbnail": ThumbnailField(),
    }

    def get_artwork_hash(self):
        return get_sha3_512_func_bytes(self.image)

    # TODO: these staticmethods can go somewhere else
    @staticmethod
    def generate_fingerprints(imagedata):
        # TODO: do this properly
        print("MOCKING __generate_fingerprints!")
        prints = [float(x) for x in range(0, 8064)]
        return prints

    @staticmethod
    def generate_luby_chunks(imagedata):
        # TODO: do this properly
        print("MOCKING __generate_luby_chunks!")
        chunks = []
        processed = 0
        while processed < len(imagedata):
            chunks.append(imagedata[processed:processed + 1024 * 1024])
            processed += 1024 * 1024
        return chunks

    @staticmethod
    def generate_thumbnail(imagedata):
        # TODO: do this properly
        print("MOCKING __generate_thumbnail!")
        return b"\x89PNGTESTTESTTEST"

    def get_luby_hashes(self):
        hashes = []
        for chunk in self.lubychunks:
            hashes.append(get_sha3_512_func_bytes(chunk))
        return hashes

    def get_thumbnail_hash(self):
        return get_sha3_512_func_bytes(self.thumbnail)

    def validate(self):
        # validate that luby chunks are good
        # TODO: we should rather do this by:
        #   o assembling the original image and making sure it matches
        #   o checking if chunks are actually generated well
        new_luby_chunks = self.generate_luby_chunks(self.image)
        assert(self.lubychunks == new_luby_chunks)

        # validate that thumbnail is the same image
        # TODO: we should not regenerate the thumbnail, just look for similarities
        new_thumbnail = self.generate_thumbnail(self.image)
        assert(self.thumbnail == new_thumbnail)


class RegistrationTicket(TicketModelBase):
    methods = {
        "artist_name": StringField(minsize=0, maxsize=120),
        "artist_website": StringField(minsize=0, maxsize=120),
        "artist_written_statement": StringField(minsize=0, maxsize=120),
        "artwork_title": StringField(minsize=0, maxsize=120),
        "artwork_series_name": StringField(minsize=0, maxsize=120),
        "artwork_creation_video_youtube_url": StringField(minsize=0, maxsize=120),
        "artwork_keyword_set": StringField(minsize=0, maxsize=120),
        "total_copies": IntegerField(minsize=0, maxsize=120),

        "fingerprints": ListField(minsize=8064, maxsize=8064, innertype=float),
        "lubyhashes": LubyChunkHashField(),
        "thumbnailhash": SHA3512Field(),

        "author": PubkeyField(),
        "imagedata_hash": SHA3512Field(),
    }

    def validate(self, blockchain):
        # we have no way to check these but will do so on activation:
        #  o lubyhashes
        #  o thumbnailhash
        #
        # after these checks are done we know that fingerprints are not dupes and there is no race

        # validate that art hash doesn't exist:
        if blockchain.get_artwork(self.imagedata_hash) is not None:
            raise ValueError("Artwork already exists on chain: %s" % self.imagedata_hash)

        # validate that fingerprints are not dupes
        all_fingerprints = blockchain.get_all_fingerprints()
        # TODO: check for fingerprint dupes


class ActivationTicket(TicketModelBase):
    methods = {
        "author": PubkeyField(),
        "registration_ticket_txid": TXIDField(),
    }

    def validate(self, masternode_ordering, blockchain, image):
        # TODO:
        # X validate that this ticket references a valid regticket
        #   X regticket is on chain
        #   X regticket is not yet activated
        #   X regticket signatures are valid
        # X validate metadata:
        #   X fingerprints matches image
        #   X lubyhashes matches image
        #   X thumbnailhash matches image
        # X validate image
        #   X image actually hashes to imagedata_hash in the regticket
        #   X image is sfw - TODO: can we do this in the prev step using some fingerprint?
        #   X luby chunks generate the image

        # TODO: check that final_regticket ticket is not activated yet

        # get registration ticket
        final_regticket_serialized = blockchain.retrieve_data_from_utxo(self.registration_ticket_txid)
        final_regticket = FinalRegistrationTicket(serialized=final_regticket_serialized)

        # validate final ticket
        final_regticket.validate(masternode_ordering, blockchain)

        # validate registration ticket
        regticket = final_regticket.ticket

        # validate that imagehash, fingerprints, lubyhashes and thumbnailhash indeed belong to the image
        assert(regticket.fingerprints == image.generate_fingerprints("MOCK_IMAGEDATA"))
        assert(regticket.lubyhashes == image.get_luby_hashes())
        assert(regticket.thumbnailhash == image.get_thumbnail_hash())

        # image hash matches regticket hash
        assert(regticket.imagedata_hash == image.get_artwork_hash())

        # run nsfw check
        # TODO

        # run luby chunk check
        # TODO


class Signature(TicketModelBase):
    methods = {
        "signature": SignatureField(),
        "pubkey": PubkeyField(),
    }

    def validate(self, ticket):
        if not animecoin_id_verify_signature_with_public_key_func(ticket.serialize(), self.signature, self.pubkey):
            raise ValueError("Invalid signature")


class FinalTicket(TicketModelBase):
    def validate(self, masternode_ordering, blockchain):
        # # TODO: get masternode_list properly from blockchain
        # # get registration ticket
        # serialized_final_regticket = blockchain.retrieve_data_from_utxo(self.activation_ticket.registration_ticket_txid)
        # final_regticket = FinalRegistrationTicket(serialized=serialized_final_regticket)
        # final_regticket.validate(masternode_ordering, blockchain)

        # TODO: get masternode_list properly from blockchain

        # validate that the author is correct and pubkeys match MNs
        if self.signature_author.pubkey != self.ticket.author:
            raise ValueError("Signature pubkey does not match regticket.author!")

        if (self.signature_1.pubkey != masternode_ordering[0] or
            self.signature_2.pubkey != masternode_ordering[1] or
            self.signature_3.pubkey != masternode_ordering[2]):
            raise ValueError("Invalid pubkey for masternode ordering")

        # validate signatures
        self.signature_author.validate(self.ticket)
        self.signature_1.validate(self.ticket)
        self.signature_2.validate(self.ticket)
        self.signature_3.validate(self.ticket)

        # TODO: make sure the ticket was paid for
        # TODO: validate that MN list is correct


class FinalRegistrationTicket(FinalTicket):
    methods = {
        "ticket": RegistrationTicket,
        "signature_author": Signature,
        "signature_1": Signature,
        "signature_2": Signature,
        "signature_3": Signature,
    }


class FinalActivationTicket(FinalTicket):
    methods = {
        "ticket": ActivationTicket,
        "signature_author": Signature,
        "signature_1": Signature,
        "signature_2": Signature,
        "signature_3": Signature,
    }
# ===== END ===== #
