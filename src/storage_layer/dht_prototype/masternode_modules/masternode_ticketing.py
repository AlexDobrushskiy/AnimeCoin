from .models_new import RegistrationTicket, Signature, FinalRegistrationTicket, ActivationTicket, ImageData
from dht_prototype.masternode_modules.animecoin_modules.animecoin_keys import animecoin_id_keypair_generation_func
from dht_prototype.masternode_modules.animecoin_modules.animecoin_signatures import\
    animecoin_id_write_signature_on_data_func, animecoin_id_verify_signature_with_public_key_func
from dht_prototype.masternode_modules.mockchain import ChainWrapper


class RegistrationServer:
    def __init__(self, blockchain, chunkstorage):
        self.__priv, self.__pub = animecoin_id_keypair_generation_func()
        self.__chainwrapper = ChainWrapper(blockchain)
        self.__chunkstorage = chunkstorage

        # register on blockchain
        self.__chainwrapper.store_ticket(tickettype="pubkey", data=self.__pub)
        self.__chainwrapper.register_masternode(self.__pub, self)

    def masternode_sign_registration_ticket(self, signature_serialized, regticket_serialized):
        # parse inputs
        signed_regticket = Signature(serialized=signature_serialized)
        regticket = RegistrationTicket(serialized=regticket_serialized)

        # validate client's signature on the ticket
        assert(signed_regticket.pubkey == regticket.author)
        signed_regticket.validate(regticket)

        # validate registration ticket
        regticket.validate(self.__chainwrapper)

        # sign regticket
        ticket_signed_by_mn = Signature(dictionary={
            "signature": animecoin_id_write_signature_on_data_func(regticket_serialized, self.__priv, self.__pub),
            "pubkey": self.__pub,
        })
        return ticket_signed_by_mn.serialize()

    def masternode_sign_activation_ticket(self, signature_serialized, activationticket_serialized, image_serialized):
        # parse inputs
        signed_actticket = Signature(serialized=signature_serialized)
        image = ImageData(serialized=image_serialized)
        activation_ticket = ActivationTicket(serialized=activationticket_serialized)

        # validate client's signature on the ticket - so only original client can activate
        assert (signed_actticket.pubkey == activation_ticket.author)
        signed_actticket.validate(activation_ticket)

        # validate activation ticket
        activation_ticket.validate(self.__chainwrapper, image)

        # sign activation ticket
        ticket_signed_by_mn = Signature(dictionary={
            "signature": animecoin_id_write_signature_on_data_func(activationticket_serialized, self.__priv, self.__pub),
            "pubkey": self.__pub,
        })
        return ticket_signed_by_mn.serialize()

    def masternode_place_ticket_on_blockchain(self, ticket):
        # validate signed ticket
        ticket.validate(self.__chainwrapper)

        # place ticket on the blockchain
        return self.__chainwrapper.store_ticket(tickettype="dataticket", data=ticket.serialize())

    def masternode_place_image_data_in_chunkstorage(self, regticket_txid, imagedata_serialized):
        imagedata = ImageData(serialized=imagedata_serialized)
        image_hash = imagedata.get_thumbnail_hash()

        # verify that this is an actual image that is being registered
        final_regticket_serialized = self.__chainwrapper.retrieve_ticket(regticket_txid)
        final_regticket = FinalRegistrationTicket(serialized=final_regticket_serialized)
        final_regticket.validate(self.__chainwrapper)

        # store thumbnail
        self.__chunkstorage.set(image_hash, imagedata.thumbnail)

        # store chunks
        for chunkhash, chunkdata in zip(imagedata.get_luby_hashes(), imagedata.lubychunks):
            self.__chunkstorage.set(chunkhash, chunkdata)
