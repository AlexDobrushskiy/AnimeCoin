from .models_new import RegistrationTicket, Signature, FinalRegistrationTicket, ActivationTicket,\
    FinalActivationTicket, ImageData
from dht_prototype.masternode_modules.animecoin_modules.animecoin_keys import animecoin_id_keypair_generation_func
from dht_prototype.masternode_modules.animecoin_modules.animecoin_signatures import\
    animecoin_id_write_signature_on_data_func, animecoin_id_verify_signature_with_public_key_func


class RegistrationServer:
    def __init__(self, blockchain, chunkstorage):
        self.__priv, self.__pub = animecoin_id_keypair_generation_func()
        self.__blockchain = blockchain
        self.__chunkstorage = chunkstorage

        # register on blockchain
        self.__blockchain.register_pubkey(self.__pub)
        self.__blockchain.register_masternode(self.__pub, self)

    def masternode_sign_registration_ticket(self, signature_serialized, regticket_serialized):
        # parse inputs
        signed_regticket = Signature(serialized=signature_serialized)
        regticket = RegistrationTicket(serialized=regticket_serialized)

        # validate client's signature on the ticket
        assert(signed_regticket.pubkey == regticket.author)
        signed_regticket.validate(regticket)

        # validate registration ticket
        regticket.validate(self.__blockchain)

        # sign regticket
        ticket_signed_by_mn = Signature(dictionary={
            "signature": animecoin_id_write_signature_on_data_func(regticket_serialized, self.__priv, self.__pub),
            "pubkey": self.__pub,
        })
        return ticket_signed_by_mn.serialize()

    def masternode_sign_activation_ticket(self, signature_serialized, activationticket_serialized, image_serialized,
                                          masternode_ordering):
        # parse inputs
        signed_actticket = Signature(serialized=signature_serialized)
        image = ImageData(serialized=image_serialized)
        activation_ticket = ActivationTicket(serialized=activationticket_serialized)

        # validate client's signature on the ticket - so only original client can activate
        assert (signed_actticket.pubkey == activation_ticket.author)
        signed_actticket.validate(activation_ticket)

        # validate activation ticket
        activation_ticket.validate(masternode_ordering, self.__blockchain, image)

        # sign activation ticket
        ticket_signed_by_mn = Signature(dictionary={
            "signature": animecoin_id_write_signature_on_data_func(activationticket_serialized, self.__priv, self.__pub),
            "pubkey": self.__pub,
        })
        return ticket_signed_by_mn.serialize()

    def masternode_place_ticket_on_blockchain(self, ticket, masternode_ordering):
        # validate signed ticket
        ticket.validate(masternode_ordering, self.__blockchain)

        # place ticket on the blockchain
        return self.__blockchain.store_data_in_utxo(ticket.serialize())

    def masternode_place_image_data_in_chunkstorage(self, imagedata_serialized):
        # TODO: verify that this is a valid request
        imagedata = ImageData(serialized=imagedata_serialized)

        # store thumbnail
        self.__chunkstorage.set(imagedata.get_thumbnail_hash(), imagedata.thumbnail)

        # store chunks
        for chunkhash, chunkdata in zip(imagedata.get_luby_hashes(), imagedata.lubychunks):
            self.__chunkstorage.set(chunkhash, chunkdata)

