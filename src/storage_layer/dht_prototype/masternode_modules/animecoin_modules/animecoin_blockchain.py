import struct
import random
from binascii import unhexlify
from decimal import Decimal

base_transaction_amount = 0.000001
COIN = 100000000  #satoshis in 1 btc
FEEPERKB = Decimal(0.0001)
OP_CHECKSIG = b'\xac'
OP_CHECKMULTISIG = b'\xae'
OP_PUSHDATA1 = b'\x4c'
OP_DUP = b'\x76'
OP_HASH160 = b'\xa9'
OP_EQUALVERIFY = b'\x88'


def unhexstr(str):
    return unhexlify(str.encode('utf8'))


def select_txins(value, unspent):
    # TODO: make sure this is always one input!
    random.shuffle(unspent)
    r = []
    total = 0
    for tx in unspent:
        total += tx['amount']
        r.append(tx)
        if total >= value:
            break
    if total < value:
        return None
    else:
        return (r, total)


def varint(n):
    if n < 0xfd:
        return bytes([n])
    elif n < 0xffff:
        return b'\xfd' + struct.pack('<H', n)
    else:
        assert False


def packtxin(prevout, scriptSig, seq=0xffffffff):
    return prevout[0][::-1] + struct.pack('<L', prevout[1]) + varint(len(scriptSig)) + scriptSig + struct.pack('<L',
                                                                                                               seq)


def packtxout(value, scriptPubKey):
    return struct.pack('<Q', int(value * COIN)) + varint(len(scriptPubKey)) + scriptPubKey


def packtx(txins, txouts, locktime=0):
    r = b'\x01\x00\x00\x00'  # version
    r += varint(len(txins))
    for txin in txins:
        r += packtxin((unhexstr(txin['txid']), txin['vout']), b'')
    r += varint(len(txouts))
    for (value, scriptPubKey) in txouts:
        r += packtxout(value, scriptPubKey)
    r += struct.pack('<L', locktime)
    return r


def pushdata(data):
    assert len(data) < OP_PUSHDATA1[0]
    return bytes([len(data)]) + data


def pushint(n):
    assert 0 < n <= 16
    return bytes([0x51 + n - 1])


def addr2bytes(s):
    digits58 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
    n = 0
    for c in s:
        n *= 58
        if c not in digits58:
            raise ValueError
        n += digits58.index(c)
    h = '%x' % n
    if len(h) % 2:
        h = '0' + h
    for c in s:
        if c == digits58[0]:
            h = '00' + h
        else:
            break
    return unhexstr(h)[1:-4]  # skip version and checksum


def checkmultisig_scriptPubKey_dump(fd):
    data = fd.read(65 * 3)
    if not data:
        return None
    r = pushint(1)
    n = 0
    while data:
        chunk = data[0:65]
        data = data[65:]
        if len(chunk) < 33:
            chunk += b'\x00' * (33 - len(chunk))
        elif len(chunk) < 65:
            chunk += b'\x00' * (65 - len(chunk))
        r += pushdata(chunk)
        n += 1
    r += pushint(n) + OP_CHECKMULTISIG
    return r
