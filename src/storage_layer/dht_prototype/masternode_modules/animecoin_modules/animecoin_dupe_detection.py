import multiprocessing
from collections import OrderedDict

import numpy as np
import pandas as pd
import keras
from keras.applications.imagenet_utils import preprocess_input

from .animecoin_statistics import calculate_spearmans_rho, calculate_kendalls_tau, calculate_bootstrapped_hoeffdings


NUM_WORKERS = int(round(multiprocessing.cpu_count() / 2))


class DupeDetector:
    def __init__(self):
        self.DUPE_DETECTION_MODELS = OrderedDict()
        self.DUPE_DETECTION_MODELS['VGG16'] = keras.applications.vgg16.VGG16(weights='imagenet', include_top=False, pooling='avg')
        self.DUPE_DETECTION_MODELS['Xception'] = keras.applications.xception.Xception(weights='imagenet', include_top=False, pooling='avg')
        self.DUPE_DETECTION_MODELS['InceptionResNetV2'] = keras.applications.inception_resnet_v2.InceptionResNetV2(weights='imagenet', include_top=False, pooling='avg')
        self.DUPE_DETECTION_MODELS['DenseNet201'] = keras.applications.DenseNet201(weights='imagenet', include_top=False, pooling='avg')
        self.DUPE_DETECTION_MODELS['InceptionV3'] = keras.applications.inception_v3.InceptionV3(weights='imagenet', include_top=False, pooling='avg')

        # # Unused models
        # self.DUPE_DETECTION_MODELS['VGG19'] = keras.applications.vgg19.VGG19(weights='imagenet', include_top=False, pooling='avg')
        # self.DUPE_DETECTION_MODELS['MobileNet'] = keras.applications.mobilenet.MobileNet(weights='imagenet', include_top=False, pooling='avg')
        # self.DUPE_DETECTION_MODELS['ResNet50'] = keras.applications.resnet50.ResNet50(weights='imagenet', include_top=False, pooling='avg')

    def __prepare_fingerprint_for_export(self, image_feature_data):
        image_feature_data_arr = np.char.mod('%f', image_feature_data)  # convert from Numpy to a list of values
        # convert image data to float64 matrix. float64 is need for bh_sne
        x_data = np.asarray(image_feature_data_arr).astype('float64')
        image_fingerprint_vector = x_data.reshape((x_data.shape[0], -1))
        return image_fingerprint_vector

    def compute_deep_learning_features(self, image):
        # the image is now in an array of shape (3, 224, 224) but we need to expand it to (1, 2, 224, 224) as
        # Keras is expecting a list of images
        x = np.expand_dims(image, axis=0)
        x = preprocess_input(x)

        fingerprints = {}
        for k, v in self.DUPE_DETECTION_MODELS.items():
            features = v.predict(x)[0]  # extract the features
            fingerprint_vector = self.__prepare_fingerprint_for_export(features)
            fingerprints[k] = fingerprint_vector

        return fingerprints


def measure_similarity(candidate_fingerprint, fingerprint_table):
    spearman_thresh = 0.86
    kendall_thresh = 0.80
    hoeffding_thresh = 0.48
    # spearman_thresh = 0.6
    # kendall_thresh = 0.60
    # hoeffding_thresh = 0.3
    strictness = 0.99
    kendall_max = 0
    hoeffding_max = 0

    is_duplicate = False

    print('Checking if candidate image is a likely duplicate of a previously registered artwork:')

    registered_fingerprints = fingerprint_table.iloc[:, 2:].T.values
    print('Comparing candidate image to the fingerprints of %s previously registered images.' % len(fingerprint_table))
    print('Each fingerprint consists of %s numbers.' % len(fingerprint_table.columns))

    # Computing Spearman's Rho, which is fast to compute. We only perform the
    # slower tests on the fingerprints that have a high Rho
    print("Computing Spearman's Rho")
    spearman_vector, spearman_max, requires_kendalls = calculate_spearmans_rho(candidate_fingerprint,
                                                                               fingerprint_table,
                                                                               registered_fingerprints,
                                                                               strictness,
                                                                               spearman_thresh)
    # do we need to calculate Kendall's?
    if len(requires_kendalls) > 0:
        print("Computing Kendall's Tau")
        requires_hoeffdings = calculate_kendalls_tau(candidate_fingerprint, requires_kendalls, strictness, kendall_thresh)

        # do we need to calculate hoeffdings?
        if len(requires_hoeffdings) > 0:
            print("Computing Bootstrapped Hoeffding's")
            duplicates = calculate_bootstrapped_hoeffdings(candidate_fingerprint, spearman_vector, requires_hoeffdings,
                                                           strictness, hoeffding_thresh, NUM_WORKERS)

            # it seems we have found a duplicate
            if len(duplicates):
                is_duplicate = True

                print('WARNING! Art image file appears to be a duplicate!')
                print('Candidate appears to be a duplicate of the image fingerprint beginning with %s' % duplicates[0][0:5])

                for ii in range(len(fingerprint_table)):
                    current_fingerprint = registered_fingerprints[:, ii].tolist()
                    if current_fingerprint == duplicates[0]:
                        shahash = fingerprint_table.iloc[ii, 0]
                        print('The SHA256 hash of the registered artwork that is similar to the candidate image: ' + shahash)

    # assemble parameters
    column_headers = ['spearman_thresh', 'kendall_thresh', 'hoeffding_thresh',
                      'strictness', 'fingerprint_db_size', 'spearman_max',
                      'kendall_max', 'hoeffding_max']
    params_df = pd.DataFrame([spearman_thresh, kendall_thresh, hoeffding_thresh, strictness,
                              float(len(fingerprint_table)), spearman_max, kendall_max, hoeffding_max]).T
    params_df.columns = column_headers
    params_df = params_df.T

    return is_duplicate, params_df
