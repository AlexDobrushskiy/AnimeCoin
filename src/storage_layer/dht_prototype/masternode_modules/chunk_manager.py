import os
from collections import deque

from .settings import NetWorkSettings
from .chunk_storage import ChunkStorage
from .helpers import get_digest, get_hexdigest, get_intdigest, hex_to_int, int_to_hex


class Chunk:
    def __init__(self, chunkid, exists=False, verified=False, is_ours=False):
        if type(chunkid) != int:
            raise ValueError("chunkid is not int!")

        self.chunkid = chunkid
        self.exists = exists
        self.verified = verified
        self.is_ours = is_ours

    def __str__(self):
        return "chunkid: %s, exists: %s, verified: %s, is_ours: %s" % (self.chunkid, self.exists,
                                                                       self.verified, self.is_ours)


class ChunkManager:
    def __init__(self, nodeid, masternode_settings, chunks, mn_manager):
        ### START - variables
        # our node id
        self.__nodeid = hex_to_int(nodeid)

        # settings
        self.__masternode_settings = masternode_settings

        # the actual storage layer
        self.__storage = ChunkStorage(os.path.join(self.__masternode_settings.BASEDIR, "chunkdata"), mode=0o0700)

        # databases we keep
        self.__file_db = {}
        self.__alias_db = {}

        # helper lookup table for alias generation and other nodes
        self.__alias_digests = []

        # table of every chunk we know of
        self.__chunk_table = set()

        # masternode manager
        self.__mn_manager = mn_manager

        # todolist
        # TODO: use the todolist and defer all blokcing tasks to it
        self.__todolist = deque()
        ### END

        self.__initialize(chunks)

    def __initialize(self, chunks):
        # sanity check
        self.__mn_manager.get(self.__nodeid)

        # initializations
        self.__init_chunk_table(chunks)
        self.__init_alias_digests()
        self.__discover_files_in_local_storage()
        self.__mark_chunks_we_own()
        self.__purge_orphaned_files()

    def __init_chunk_table(self, chunks):
        for chunk_str in chunks:
            chunk = int(chunk_str, 16)
            self.__chunk_table.add(chunk)

    def __init_alias_digests(self):
        for i in range(self.__masternode_settings.REPLICATION_FACTOR):
            digest = get_digest(i.to_bytes(1, byteorder='big') + NetWorkSettings.ALIAS_SEED)
            self.__alias_digests.append(int.from_bytes(digest, byteorder='big'))

    def __discover_files_in_local_storage(self):
        # reads the filesystem and fills our DB of chunks we have
        for chunkid in self.__storage.index():
            # verify the chunk
            if not self.__storage.verify(chunkid):
                print("Verify failed for chunkid %s, deleting" % chunkid)
                self.__storage.delete(chunkid)
                continue

            # update our database
            if self.__file_db.get(chunkid) is None:
                chunk = Chunk(chunkid=chunkid)
            else:
                chunk = self.__file_db[chunkid]

            chunk.exists = True
            chunk.verified = True
            chunk.is_ours = False  # we don't know yet whether this is our chunk

    def __mark_chunks_we_own(self):
        for alias_digest in self.__alias_digests:
            for chunkid in self.__chunk_table:
                alt_key = alias_digest ^ chunkid

                if self.__we_own_this_alt_key(alt_key):
                    # store this chunk in the alias DB
                    self.__alias_db[alt_key] = chunkid

                    # mark this chunk as owned by us
                    self.__mark_chunk_as_owned(chunkid)

    def __we_own_this_alt_key(self, alt_key):
        my_distance = alt_key ^ self.__nodeid

        # check if we are the closest to this chunk
        store = True
        for othernodeid in self.__mn_manager.get_other_nodes(self.__nodeid):
            if alt_key ^ othernodeid < my_distance:
                store = False
                break

        return store

    def __purge_orphaned_files(self):
        for chunkid, chunk in self.__file_db.items():
            if chunk.exists:
                if not chunk.is_ours or not chunk.verified:
                    self.__storage.delete(chunkid)

    def __mark_chunk_as_owned(self, chunkid):
        # mark this chunk as owned and fetch if necessary
        if self.__file_db.get(chunkid) is None:
            self.__file_db[chunkid] = Chunk(chunkid=chunkid)

        # mark the chunk as ours
        chunk = self.__file_db[chunkid]
        chunk.is_ours = True

        # if we don't have it or it's not verified for some reason, fetch it
        if not chunk.exists or not chunk.verified:
            # TODO: do this properly
            pass

    def update_mn_list(self, masternode_list):
        # update the MN list
        # reassign chunks
        # create tasks to fetch chunks
        # purge old chunks
        pass

    def new_chunks_added_from_blockchain(self):
        # add new chunks to db
        # calculate if we need to store them
        # create tasks to fetch chunks
        pass

    def purge_old_chunks(self):
        # clean up chunks we no longer need
        pass

    def get_chunk(self):
        # test if we have the chunk
        # return the chunk
        pass

    def fetch_chunk(self):
        # fetch the chunk from other MNs
        pass
