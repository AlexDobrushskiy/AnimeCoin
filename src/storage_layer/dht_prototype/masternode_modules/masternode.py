import asyncio
import zmq
import zmq.asyncio
import uuid

from .helpers import hex_to_int, int_to_hex
from .rpcprotocol import serialize, deserialize


class MasterNode:
    def __init__(self, nodeid, ip, port, pubkey):
        self.nodeid = nodeid
        self.ip = ip
        self.port = port
        self.pubkey = pubkey

        self.__zmq = None

        # TODO
        self.__reputation = None

    def __eq__(self, other):
        return self.__dict__ == other.__dict__

    async def __send_rpc(self, rpcname, data):
        ctx = zmq.asyncio.Context()
        if self.__zmq is None:
            self.__zmq = ctx.socket(zmq.DEALER)
            self.__zmq.setsockopt(zmq.IDENTITY, bytes(str(uuid.uuid4()), "utf-8"))
            self.__zmq.connect("tcp://%s:%s" % (self.ip, self.port))

        request_packet = serialize(rpcname, data)

        print("Sent RPC %s to MN: %s" % (rpcname, self.nodeid))
        await self.__zmq.send_multipart([request_packet])

        msgs = await self.__zmq.recv_multipart()  # waits for msg to be ready
        if len(msgs) > 1:
            raise ValueError("msgs must be 1, we don't use multipart messages: %s" % msgs)

        msg = msgs[0]
        print("Received RPC reply %s from %s" % (msg, self.nodeid))

        return deserialize(msg)

    async def spotcheck(self, chunkid, start, end):
        rpcname, data = await self.__send_rpc("SPOTCHECK_REQ", {"chunkid": chunkid, "start": start, "end": end})
        if rpcname != "SPOTCHECK_RESP":
            raise ValueError("Spotcheck response has rpc name: %s" % rpcname)

        if set(data.keys()) != set(["digest"]):
            raise ValueError("RPC parameters are wrong for SPOTCHECK_RESP: %s" % data.keys())

        if type(data["digest"]) != str:
            raise TypeError("digest is not str: %s" % type(data["digest"]))

        return data["digest"]


class MasterNodeManager:
    def __init__(self, masternode_list):
        self.__masternodes = self.__parse_masternode_list(masternode_list)

    def __parse_masternode_list(self, masternode_list):
        masternodes = {}
        for nodeid, ip, port, pubkey in masternode_list:
            nodeid = hex_to_int(nodeid)
            masternodes[nodeid] = MasterNode(nodeid, ip, port, pubkey)
        return masternodes

    def get(self, nodeid):
        return self.__masternodes[nodeid]

    def get_all(self):
        return list(self.__masternodes.values())

    def get_other_nodes(self, mynodeid):
        other_nodes = []
        for mn in self.__masternodes.values():
            if mn.nodeid != mynodeid:
                other_nodes.append(mn.nodeid)
        return other_nodes

    def update_maternode_list(self, masternode_list):
        new_mn_list = self.__parse_masternode_list(masternode_list)
        old = set(self.__masternodes.keys())
        new = set(new_mn_list.keys())
        added = new-old
        removed = old-new
        self.__masternodes = new_mn_list
        return added, removed
