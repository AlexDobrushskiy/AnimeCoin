from .settings import NetWorkSettings


class ListField:
    def __init__(self, minsize, maxsize, innertype):
        self.minsize = minsize
        self.maxsize = maxsize
        self.innertype = innertype

    def validate(self, value):
        if type(value) != list:
            raise TypeError("value is not list, was: %s" % type(value))

        if len(value) < self.minsize or len(value) > self.maxsize:
            raise ValueError("value is out of bound (value < minsize or value > maxsize), was: %s" % len(value))

        for element in value:
            if type(element) != self.innertype:
                raise TypeError("element is not %s, was: %s" % (self.innertype, type(element)))

        # TODO: implement innermin and innermax
        # as msgpack does not support bignum ints and floats, but python does

        return value


class LubyChunkHashField:
    # TODO: maybe refactor this to be more generic
    def validate(self, value):
        if type(value) != list:
            raise TypeError("value is not list, was: %s" % type(value))

        validator = SHA3512Field()
        for element in value:
            validator.validate(element)

        return value


class LubyChunkField:
    # TODO: maybe refactor this to be more generic
    def validate(self, value):
        if type(value) != list:
            raise TypeError("value is not list, was: %s" % type(value))

        validator = BytesField(minsize=0, maxsize=NetWorkSettings.CHUNKSIZE)
        for element in value:
            validator.validate(element)

        return value


class NotImplementedType:
    def __eq__(self, other):
        raise NotImplementedError()


class ListTypeValidatorField:
    accepted_type = NotImplementedType()

    def __init__(self, minsize, maxsize):
        self.minsize = minsize
        self.maxsize = maxsize

    def validate(self, value):
        if type(value) != self.accepted_type:
            raise TypeError("value is not %s, was: %s" % (self.accepted_type, type(value)))

        if len(value) < self.minsize or len(value) > self.maxsize:
            raise ValueError("value is out of bound (value < minsize or value > maxsize), was: %s" % len(value))

        return value


class ImageField(ListTypeValidatorField):
    accepted_type = bytes

    def __init__(self):
        super().__init__(0, NetWorkSettings.IMAGE_MAX_SIZE)

    # TODO: validate that this is an actual proper image


class ThumbnailField(ListTypeValidatorField):
    accepted_type = bytes

    def __init__(self):
        super().__init__(0, NetWorkSettings.THUMBNAIL_MAX_SIZE)


class IntTypeValidatorField:
    accepted_type = NotImplementedType()

    def __init__(self, minsize, maxsize):
        self.minsize = minsize
        self.maxsize = maxsize

    def validate(self, value):
        if type(value) != self.accepted_type:
            raise TypeError("value is not %s, was: %s" % (self.accepted_type, type(value)))

        if value < self.minsize or value > self.maxsize:
            raise ValueError("value is out of bound (value < minsize or value > maxsize), was: %s" % value)

        return value


class BytesField(ListTypeValidatorField):
    accepted_type = bytes


class StringField(ListTypeValidatorField):
    # TODO: validate byte length not string length:
    # to get byte length use: len(s.encode("utf-8"))
    accepted_type = str


class IntegerField(IntTypeValidatorField):
    accepted_type = int


class PubKeyField(BytesField):
    def __init__(self, minsize, maxsize):
        super().__init__(minsize, maxsize)

    def validate(self, value):
        # TODO: validate that this is an actual key
        return super().validate(value)


class SHA3512Field(BytesField):
    def __init__(self):
        super().__init__(minsize=64, maxsize=64)


class SHA2256Field(BytesField):
    def __init__(self):
        super().__init__(minsize=32, maxsize=32)


class TXIDField(SHA2256Field):
    pass


# NOTE: Version is not included in here as we can rely on the blockchain for versioning
ARTREGISTRATION_KEYS = {
    "ARTIST_PUBKEY": PubKeyField(minsize=0, maxsize=132),
    "ARTWORK_TITLE": StringField(minsize=0, maxsize=120),
    "ARTIST_NAME": StringField(minsize=0, maxsize=120),
    "ARTWORK_SERIES_NAME": StringField(minsize=0, maxsize=120),
    "ARTWORK_CREATION_VIDEO_YOUTUBE_URL": StringField(minsize=0, maxsize=120),
    "ARTIST_WEBSITE": StringField(minsize=0, maxsize=120),
    "ARTIST_WRITTEN_STATEMENT": StringField(minsize=0, maxsize=120),
    "ARTWORK_KEYWORD_SET": StringField(minsize=0, maxsize=120),
    "TOTAL_COPIES": IntegerField(minsize=0, maxsize=120),
    "IMAGE_HASH": SHA3512Field,
    # "IMAGE_FINGERPRINT_HASH": BytesField(minsize=64, maxsize=64),
    # "IMAGE_FINGERPRINTS": ListField(minsize=8064, maxsize=8064, innertype=float),
}

ARTACTIVATION_KEYS = {
    "ART_REGISTRATION_TICKET_ID": TXIDField(),
    "ARTIST_PUBKEY": PubKeyField(minsize=0, maxsize=132),
}


class ArtRegistrationRequestValidator:
    def __init__(self, datadict):
        self.__validated = {}

        # validate all keys for this version
        a, b = set(datadict.keys()), set(ARTREGISTRATION_KEYS.keys())
        if len(a - b) + len(b - a) > 0:
            raise KeyError("Keys don't match %s != %s" % (a, b))

        for k, v in datadict.items():
            validator = ARTREGISTRATION_KEYS[k]
            self.__validated[k] = validator.validate(v)

    def get_dict(self):
        return self.__validated.copy()


class ArtActivationTicketValidator:
    def __init__(self, datadict):
        self.__validated = {}

        # validate all keys for this version
        a, b = set(datadict.keys()), set(ARTACTIVATION_KEYS.keys())
        if len(a - b) + len(b - a) > 0:
            raise KeyError("Keys don't match %s != %s" % (a, b))

        for k, v in datadict.items():
            validator = ARTACTIVATION_KEYS[k]
            self.__validated[k] = validator.validate(v)

    def get_dict(self):
        return self.__validated.copy()
