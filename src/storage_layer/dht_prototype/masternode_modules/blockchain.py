import binascii
import io

import sys
from binascii import hexlify
from decimal import Decimal

from bitcoinrpc.authproxy import AuthServiceProxy

from dht_prototype.masternode_modules.animecoin_modules.animecoin_blockchain import OP_CHECKSIG, OP_PUSHDATA1, OP_HASH160,\
    OP_CHECKMULTISIG, OP_DUP, OP_EQUALVERIFY, COIN, base_transaction_amount, FEEPERKB, select_txins, unhexstr,\
    checkmultisig_scriptPubKey_dump, pushdata, pushint, addr2bytes, packtx

from dht_prototype.masternode_modules.helpers import get_hexdigest, get_digest
from dht_prototype.masternode_modules.settings import NetWorkSettings


class BlockChain:
    def __init__(self, user, password, ip, port):
        url = "http://%s:%s@%s:%s" % (user, password, ip, port)
        self.__rpc_connection = AuthServiceProxy(url)

    # START EXPOSED RPC CALLS
    def getbestblockhash(self):
        return self.__rpc_connection.getbestblockhash()

    def generate(self, amount):
        return self.__rpc_connection.generate(amount)

    def listunspent(self):
        return self.__rpc_connection.listunspent()

    def getwalletinfo(self):
        return self.__rpc_connection.getwalletinfo()
    # END EXPOSED RPC CALLS

    def bootstrap(self, addr):
        return self.__rpc_connection.addnode(addr, "onetry")

    def store_data_in_utxo(self, input_data):
        uncompressed_file_size_in_bytes = sys.getsizeof(input_data)
        print('Now storing preparing file for storage in blockchain. Original uncompressed file size in bytes: ' + str(
            uncompressed_file_size_in_bytes) + ' bytes')

        input_data_hash = get_digest(input_data)

        # TODO: remove unnecessary hashes
        compression_dictionary_file_hash = input_data_hash
        uncompressed_data_file_hash = input_data_hash
        compressed_data_file_hash = input_data_hash

        unspent = list(self.__rpc_connection.listunspent())
        # TODO: figure out what this number should be
        (txins, change) = select_txins(1, unspent)
        txouts = []
        encoded_animecoin_zstd_compressed_data = hexlify(input_data)
        length_of_compressed_data_string = '{0:015}'.format(len(encoded_animecoin_zstd_compressed_data)).encode('utf-8')
        combined_data_hex = hexlify(length_of_compressed_data_string) + hexlify(compression_dictionary_file_hash) + hexlify(
            uncompressed_data_file_hash) + hexlify(
            compressed_data_file_hash) + encoded_animecoin_zstd_compressed_data + hexlify(('0' * 100).encode('utf-8'))
        fd = io.BytesIO(combined_data_hex)
        while True:
            scriptPubKey = checkmultisig_scriptPubKey_dump(fd)
            if scriptPubKey is None:
                break
            value = Decimal(1 / COIN)
            txouts.append((value, scriptPubKey))
            change -= value
        out_value = Decimal(base_transaction_amount)  # dest output
        change -= out_value
        receiving_animecoin_blockchain_address = self.__rpc_connection.getnewaddress()
        txouts.append((out_value, OP_DUP + OP_HASH160 + pushdata(
            addr2bytes(receiving_animecoin_blockchain_address)) + OP_EQUALVERIFY + OP_CHECKSIG))
        change_address = self.__rpc_connection.getnewaddress()  # change output
        txouts.append([change, OP_DUP + OP_HASH160 + pushdata(addr2bytes(change_address)) + OP_EQUALVERIFY + OP_CHECKSIG])
        tx = packtx(txins, txouts)
        signed_tx = self.__rpc_connection.signrawtransaction(hexlify(tx).decode('utf-8'))
        fee = Decimal(len(signed_tx['hex']) / 1000) * FEEPERKB
        change -= fee
        txouts[-1][0] = change
        final_tx = packtx(txins, txouts)
        signed_tx = self.__rpc_connection.signrawtransaction(hexlify(final_tx).decode('utf-8'))
        assert signed_tx['complete']
        hex_signed_transaction = signed_tx['hex']
        print("DBG", hex_signed_transaction)
        print('Sending data transaction to address: ' + receiving_animecoin_blockchain_address)
        print('Size: %d  Fee: %2.8f' % (len(hex_signed_transaction) / 2, fee), file=sys.stderr)
        send_raw_transaction_result = self.__rpc_connection.sendrawtransaction(hex_signed_transaction)
        blockchain_transaction_id = send_raw_transaction_result
        print('Transaction ID: ' + blockchain_transaction_id)
        return blockchain_transaction_id

    def retrieve_data_from_utxo(self, blockchain_transaction_id):
        raw = self.__rpc_connection.getrawtransaction(blockchain_transaction_id)
        outputs = raw.split('0100000000000000')
        for idx, output in enumerate(outputs):
            print(idx, output)
        encoded_hex_data = ''
        for output in outputs[1:-2]:  # there are 3 65-byte parts in this that we need
            cur = 6
            encoded_hex_data += output[cur:cur + 130]
            cur += 132
            encoded_hex_data += output[cur:cur + 130]
            cur += 132
            encoded_hex_data += output[cur:cur + 130]
        encoded_hex_data += outputs[-2][6:-4]
        reconstructed_combined_data = binascii.a2b_hex(encoded_hex_data).decode('utf-8')
        reconstructed_length_of_compressed_data_hex_string = reconstructed_combined_data[
                                                             0:30]  # len(hexlify('{0:015}'.format(len(encoded_animecoin_zstd_compressed_data)).encode('utf-8'))) is 30
        reconstructed_length_of_compressed_data_hex_string = int(
            unhexstr(reconstructed_length_of_compressed_data_hex_string).decode('utf-8').lstrip('0'))
        reconstructed_combined_data__remainder_1 = reconstructed_combined_data[30:]
        length_of_standard_hash_string = NetWorkSettings.HEX_DIGEST_SIZE
        reconstructed_compression_dictionary_file_hash = reconstructed_combined_data__remainder_1[
                                                         0:length_of_standard_hash_string]
        reconstructed_combined_data__remainder_2 = reconstructed_combined_data__remainder_1[length_of_standard_hash_string:]
        reconstructed_uncompressed_data_file_hash = reconstructed_combined_data__remainder_2[
                                                    0:length_of_standard_hash_string]
        reconstructed_combined_data__remainder_3 = reconstructed_combined_data__remainder_2[length_of_standard_hash_string:]
        input_data_hash = reconstructed_combined_data__remainder_3[0:length_of_standard_hash_string]
        reconstructed_combined_data__remainder_4 = reconstructed_combined_data__remainder_3[length_of_standard_hash_string:]
        reconstructed_encoded_animecoin_zstd_compressed_data_padded = reconstructed_combined_data__remainder_4.replace('A',
                                                                                                                       '')  # Note sure where this comes from; somehow it is introduced into the data (note this is "A" not "a").
        calculated_padding_length = len(
            reconstructed_encoded_animecoin_zstd_compressed_data_padded) - reconstructed_length_of_compressed_data_hex_string
        reconstructed_encoded_animecoin_zstd_compressed_data = reconstructed_encoded_animecoin_zstd_compressed_data_padded[
                                                               0:-calculated_padding_length]
        output_data = unhexstr(reconstructed_encoded_animecoin_zstd_compressed_data)
        hash_of_output_data = get_hexdigest(output_data)
        assert (hash_of_output_data == input_data_hash)
        print('Successfully reconstructed and decompressed data!')
        return output_data
